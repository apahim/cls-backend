{{- if not .Values.gcp.project }}
{{- fail "gcp.project is required" }}
{{- end }}
{{- include "cls-backend-application.validateDatabaseConfig" . }}
---
# Database Migration Job
apiVersion: batch/v1
kind: Job
metadata:
  name: {{ include "cls-backend-application.fullname" . }}-migration
  namespace: {{ .Values.namespace.name }}
  labels:
    {{- include "cls-backend-application.labels" . | nindent 4 }}
    app.kubernetes.io/component: migration
  annotations:
    # Run before application deployment
    "helm.sh/hook": pre-install,pre-upgrade
    "helm.sh/hook-weight": "1"
    "helm.sh/hook-delete-policy": before-hook-creation,hook-succeeded
spec:
  template:
    metadata:
      labels:
        {{- include "cls-backend-application.selectorLabels" . | nindent 8 }}
        app.kubernetes.io/component: migration
    spec:
      serviceAccountName: {{ .Values.serviceAccount.name }}
      restartPolicy: Never
      securityContext:
        {{- toYaml .Values.podSecurityContext | nindent 8 }}
      initContainers:
      - name: copy-migrations
        image: {{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}
        command: ["/bin/sh"]
        args:
        - -c
        - |
          echo "Copying migration files from cls-backend image..."
          echo "Source: /app/internal/database/migrations/"
          echo "Target: /shared/migrations/"

          # Create target directory
          mkdir -p /shared/migrations/

          # Copy all migration files
          if [ -d "/app/internal/database/migrations" ]; then
            cp -v /app/internal/database/migrations/*.sql /shared/migrations/ 2>/dev/null || echo "No .sql files found in migrations directory"

            echo "Migration files copied:"
            ls -la /shared/migrations/
          else
            echo "WARNING: Migration directory /app/internal/database/migrations not found in image"
            exit 1
          fi
        volumeMounts:
        - name: migrations-volume
          mountPath: /shared/migrations
        securityContext:
          runAsNonRoot: true
          runAsUser: 1001
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: false  # Need write access to copy files
          capabilities:
            drop:
            - ALL
      {{- if and (eq .Values.database.type "cloud-sql") .Values.database.cloudSql.enableProxy }}
      # Cloud SQL Proxy sidecar for secure database connections
      - name: cloud-sql-proxy
        image: {{ .Values.database.cloudSql.proxyImage }}
        # restartPolicy: Always is required for sidecars to remain for the duration of the job
        restartPolicy: Always
        args:
        - "--structured-logs"
        - "--port={{ .Values.database.cloudSql.proxyPort }}"
        - "--health-check"
        - "--http-address=0.0.0.0"
        - "--http-port=9801"
        - "{{ include "cls-backend-application.cloudSqlConnectionName" . }}"
        ports:
        - name: health
          containerPort: 9801
          protocol: TCP
        securityContext:
          runAsNonRoot: true
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
        startupProbe:
          httpGet:
            path: /startup
            port: health
          periodSeconds: 1
          timeoutSeconds: 5
          failureThreshold: 20
        livenessProbe:
          httpGet:
            path: /liveness
            port: health
          initialDelaySeconds: 0
          periodSeconds: 60
          timeoutSeconds: 30
          failureThreshold: 5
        readinessProbe:
          httpGet:
            path: /readiness
            port: health
          periodSeconds: 5
          timeoutSeconds: 5
          failureThreshold: 12  # 60 seconds total before marking unready
      {{- end }}
      containers:
      - name: migration
        image: postgres:15-alpine
        env:
          - name: DATABASE_URL
            valueFrom:
              secretKeyRef:
                name: {{ .Values.database.passwordSecret.name }}
                key: DATABASE_URL
        command:
        - /bin/sh
        - -c
        - |
          echo "Starting dynamic database migrations..."
          # Mask password in DATABASE_URL for logging (show only host, port, database)
          MASKED_URL=$(echo "$DATABASE_URL" | sed -E 's|(postgres://[^:]+:)[^@]+(@)|\1***\2|')
          echo "Database URL: $MASKED_URL"

          # Wait for database to be ready
          echo "Waiting for database to be ready..."
          until pg_isready -d "$DATABASE_URL"; do
            echo "Database not ready, waiting..."
            sleep 5
          done
          echo "Database is ready!"

          # Create migration tracking table if it doesn't exist
          echo "Setting up migration tracking..."
          psql "$DATABASE_URL" -c "
            CREATE TABLE IF NOT EXISTS schema_migrations (
              version VARCHAR(255) PRIMARY KEY,
              applied_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT NOW()
            );
          " || { echo "Failed to create migration tracking table"; exit 1; }

          # Navigate to migrations directory
          cd /shared/migrations || { echo "Migration directory not found"; exit 1; }

          # Check if any migration files exist
          if [ ! "$(ls -A *.sql 2>/dev/null)" ]; then
            echo "No migration files found in /shared/migrations/"
            echo "Available files:"
            ls -la /shared/migrations/
            exit 1
          fi

          echo "Found migration files:"
          ls -la *.sql

          # Apply migrations in alphabetical order (001_, 002_, 003_, etc.)
          for migration_file in $(ls *.sql | sort); do
            migration_name=$(basename "$migration_file" .sql)

            echo "Checking migration: $migration_name"

            # Check if migration has already been applied
            if psql "$DATABASE_URL" -t -c "SELECT 1 FROM schema_migrations WHERE version = '$migration_name';" | grep -q 1; then
              echo "✓ Migration $migration_name already applied, skipping"
              continue
            fi

            echo "→ Applying migration: $migration_file"

            # Apply the migration
            if psql "$DATABASE_URL" -f "$migration_file"; then
              # Mark migration as applied
              psql "$DATABASE_URL" -c "INSERT INTO schema_migrations (version) VALUES ('$migration_name');" || {
                echo "Failed to record migration $migration_name in tracking table"
                exit 1
              }
              echo "✓ Successfully applied migration: $migration_name"
            else
              echo "✗ Failed to apply migration: $migration_file"
              exit 1
            fi
          done

          echo "All database migrations completed successfully!"

          # Show applied migrations
          echo "Applied migrations:"
          psql "$DATABASE_URL" -c "SELECT version, applied_at FROM schema_migrations ORDER BY applied_at;"
        volumeMounts:
        - name: migrations-volume
          mountPath: /shared/migrations
        securityContext:
          runAsNonRoot: true
          runAsUser: 1001
          allowPrivilegeEscalation: false
          readOnlyRootFilesystem: true
          capabilities:
            drop:
            - ALL
        resources:
          requests:
            memory: "128Mi"
            cpu: "100m"
          limits:
            memory: "512Mi"
            cpu: "500m"
      volumes:
      - name: migrations-volume
        emptyDir: {}
